/**
 * @module esdf-base/reference/EventSourcedAggregateRoot
 */

const EventEmitter = require('events');
const uuid = require('uuid');
const verify = require('../utils/verify');
const ProgrammerError = require('../errors/ProgrammerError');
const MultiNumberSequence = require('../order/MultiNumberSequence');

let EventSourcedAggregateRoot;

// EventSourcedAggregateRoot symbol scope:
{
  const _ID = Symbol('EventSourcedAggregateRoot#_ID');
  const _listeners = Symbol('EventSourcedAggregateRoot#_listeners');
  const _eventHandlers = Symbol('EventSourcedAggregateRoot#_eventHandlers');
  const _eventCounter = Symbol('EventSourcedAggregateRoot#_eventCounter');

  /**
   * An event-sourced aggregate root is an Aggregate Root which uses Domain Events
   *  as a state medium. It executes methods and updates its state like any normal
   *  entity, but only does so through emitting and consuming events which
   *  express business intent. Each emitted event is applied to the aggregate
   *  using Event Handlers, which mutate state.
   * An EventSourcedAggregateRoot's state at any point in time can be restored
   *  from a stream of such events - this is called rehydration and is the primary
   *  mechanism used to load aggregates from storage.
   * This reference implementation assumes state mutability for performance
   *  and simplicity.
   * @implements {module:esdf-base/interfaces/EventSource}
   * @implements {module:esdf-base/interfaces/EventTarget}
   * @implements {module:esdf-base/interfaces/AggregateRoot}
   */
  EventSourcedAggregateRoot = class EventSourcedAggregateRoot {
    constructor(eventHandlers) {
      /**
       * The universally-unique identity of this Aggregate Root.
       * Represented as a UUID v4 or v5 (128-bit), formatted in canonical
       *  lowercase UUID format (8-4-4-4-12).
       * @type {string}
       * @private
       */
      this[_ID] = null;
      /**
       * External listeners for Domain Events.
       * @type {Set.<function>}
       * @private
       */
      this[_listeners] = new Set();
      /**
       * Event handlers - the entity's only way of performing state mutation.
       * This is a map which assigns to each event type a behavior - a function
       *  that modifies some variables in "this".
       * @type {Object.<string,function>}
       * @private
       */
      this[_eventHandlers] = eventHandlers;
      /**
       * Event counter - the sequence that generates event numbers within
       *  this Aggregate Root's event stream.
       * @type {module:esdf-base/order/MultiNumberSequence~MultiNumberSequence}
       * @private
       */
      this[_eventCounter] = null;
    }

    /**
     * Set a UUID for this Aggregate Root instance. Note that this sets/resets
     *  the internal event counter, so it is necessary to execute this before
     *  applying any events.
     * @param {string} ID - A UUID v4 or v5, formatted in 8-4-4-4-12 lowercase,
     *  like "3614d283-3e19-577b-be6d-0b940dea71c2".
     */
    setID(ID) {
      verify('ID', ID, verify.UUID());
      this[_ID] = ID;
      this[_eventCounter] = new MultiNumberSequence({ aggregateRootID: ID }, 1);
      return this;
    }

    /**
     * Get the identity of this Aggregate Root.
     * @returns {?string} The previously-set UUID, or null if none set.
     */
    getID() {
      return this._aggregateID;
    }

    /**
     * Request a listener function to be called whenever a Domain Event is
     *  generated by this Aggregate Root as a result of a business decision.
     * Re-adding a listener function will not cause it to be called twice.
     * @param {function(module:esdf-base/interfaces/DomainEvent)} listener
     */
    addListener(listener) {
      this[_listeners].add(listener);
    }

    /**
     * Stop calling a function on events. If the function is not a listener,
     *  this does nothing.
     * @param {function(module:esdf-base/interfaces/DomainEvent)} listener
     */
    removeListener(listener) {
      this[_listeners].remove(listener);
    }

    /**
     * Apply a Domain Event on this Aggregate Root to effect a state change.
     * @param {module:esdf-base/interfaces/DomainEvent} event
     */
    applyEvent(event) {
      const type = event.getType();
      const handler = this[_eventHandlers][type];
      if (!handler) {
        throw new EventSourcedAggregateRoot.Errors.NoEventHandler(type);
      }
      handler.call(this, event.getPayload());
      // Advance the counter after the event has been applied:
      this[_eventCounter] = event.getOrder().getNext();
    }

    /**
     * Emit a Domain Event. This accomplishes two things:
     * 1. Applies the effects of the corresponding Event Handler to the aggregate
     *  root's state so that it reflects the outcome of the business occurrence
     *  that the event conveys.
     * 2. Delivers the event to listeners, who may choose to persist it (this is
     *  the mechanism by which a Repository normally waits for events to save).
     * @private
     */
    _emit(type, payload) {
      // Get the current counter value:
      const order = this[_eventCounter];
      const event = new EventSourcedAggregateRoot.Event({
        ID: uuid.v4(),
        type: type,
        timestamp: new Date(),
        payload: payload,
        order: order
      });
      // Run internal handlers to advance state:
      this.applyEvent(event);
      // Call external event listeners, too:
      this[_listeners].forEach(function callRegisteredEventListener(listener) {
        listener(event);
      });
    }
  }
}

// Event symbol scope:
{
  const _ID = Symbol('Event#_ID');
  const _type = Symbol('Event#_type');
  const _timestamp = Symbol('Event#_timestamp');
  const _payload = Symbol('Event#_payload');
  const _order = Symbol('Event#_order');

  /**
   * The Event class is the reference implementation for a Domain Event coming
   *  from an EventSourcedAggregateRoot.
   * It uses random universally-unique IDs to distinguish events.
   * Events are numbered using natural numbers within their aggregate.
   * The sequential numbers may be used as the concurrency control mechanism for
   *  conflict detection in the persistence layer, since a linear Aggregate Root
   *  will never have two events parallel in its timeline.
   * @implements {module:esdf-core/interfaces/DomainEvent~DomainEvent}
   */
  class Event {
    constructor({ ID, type, timestamp, payload, order }) {
      this[_ID] = ID;
      this[_type] = type;
      this[_timestamp] = new Date(timestamp);
      this[_payload] = Object(payload);
      this[_order] = order;
    }

    getID() {
      return this[_ID];
    }

    getType() {
      return this[_type];
    }

    getTimestamp() {
      return this[_timestamp];
    }

    getPayload() {
      return this[_payload];
    }

    getOrder() {
      return this[_order];
    }
  }
  EventSourcedAggregateRoot.Event = Event;
}

EventSourcedAggregateRoot.Errors = {
  NoEventHandler: class NoEventHandler extends ProgrammerError {
    constructor(type) {
      super(`No event handler defined for event type ${type} - bailing out to avoid programmer error`);
      this.data = { type };
    }
  }
};

module.exports = EventSourcedAggregateRoot;
